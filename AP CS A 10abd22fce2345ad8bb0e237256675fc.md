# AP CS A

[Unit 1: Getting Started & Primitive Types](https://www.notion.so/Unit-1-Getting-Started-Primitive-Types-e7cffdbbb4f542cb832f69b812d06d43) 

[Unit 2: Using Objects](https://www.notion.so/Unit-2-Using-Objects-ba057cfacb094c009e1b5e5c27e19c66) 

[Unit 3: Boolean Expressions and If Statements](https://www.notion.so/Unit-3-Boolean-Expressions-and-If-Statements-2ca79f8ebb614c15930728212f4f10e0) 

[Unit 4: Iteration](https://www.notion.so/Unit-4-Iteration-022de4d075d641c38b5caf767f9875cd) 

[Unit 5: Writing Classes](https://www.notion.so/Unit-5-Writing-Classes-60120f7bd9bf438fa0c4e72c81bf0286)

[Unit 6: Array](https://www.notion.so/Unit-6-Array-8001d16cb8464ce2a1a7077064777ad0)

[Unit 7: ArrayList](https://www.notion.so/Unit-7-ArrayList-326e6daab9404e6fada5b3e880fe3767)

[Unit 8: 2D Array](https://www.notion.so/Unit-8-2D-Array-9d5da53aa6c64c0ca6013861eb620af9)

[Unit 9: Inheritance](https://www.notion.so/Unit-9-Inheritance-c6c58ccb9d454d3ea5be606ad13866bd)

[Unit 10: Recursion](https://www.notion.so/Unit-10-Recursion-03fd793d6fd94550bbccf7a5bcf25f7c) 

# Unit 1: Getting Started & Primitive Types

## 1.1 & 1.2

Java programs start with:

```java
public class Name_Of_Class {
}
```

- Class name matches the file name (**Name_Of_Class.java** in this case)

Most Java classes have a main method that will be run automatically:

```java
public static void main(String[] args) {
}
```

Print and stay on the same line:

```java
System.out.print();
```

- Doesn’t reserve the whole line for the print

Print and move to the next line:

```java
System.out.println();
```

- Prints to the line (ln)

**String literal** is enclosed in double quotes:

- “This is a string literal” → Text in-between the quotation marks is called a **literal**

**Literal**: Any constant value which can be assigned to a variable

```java
String name = "Ege";
int x = 100;
```

- Ege & 100 are literals

**Compiler** translates code into a class file that can be run by a computer

**Compiler/syntax errors** are reported by the compiler if the code is not correctly written

**Comments** are ignored by the compiler:

```java
// This is a single line comment

System.out.println("This is code!");

/*
This is a
block
comment
*/
```

## 1.3: **Variables and Data Types**

**Variable:** The name associated with a memory location in the computer where you can store a value that can change or vary

2 types of variables in Java:

- **Primitive variables**: Hold primitive types, information is stored as the actual value of that variable in the memory (ex. int, byte, short, long, float, double, boolean and char)
- **Reference variables: Used to point at object/values. Classes, interfaces, arrays, strings, enumerations, and annotations are reference types in Java. Reference variables hold the objects/values of reference types.**
    - If no object is passed to a reference variable then it will store a **null** value
    - Declaring a new instance of the class “Demo”:
    
    ```java
    Demo D1 = new Demo();
    ```
    

[https://lh3.googleusercontent.com/kTqUueWp-ap7KIQqoXis0h4MVIndKT7Cc-YFfTx-WN9-1By5KHE5Qcvhba4QCBt1R0xewfDn401SEl1OWQp8nt7kiWwxcOBZ91DgVbjclGAHX8o1sooilyaYGyR0VWS4eMN-1fvB4Eypr2-2OXw24ME](https://lh3.googleusercontent.com/kTqUueWp-ap7KIQqoXis0h4MVIndKT7Cc-YFfTx-WN9-1By5KHE5Qcvhba4QCBt1R0xewfDn401SEl1OWQp8nt7kiWwxcOBZ91DgVbjclGAHX8o1sooilyaYGyR0VWS4eMN-1fvB4Eypr2-2OXw24ME)

- Instances can’t be called from inside a **static** method.

Each variable has associated memory that is used to hold its value. The memory associated with a variable of a primitive type holds an actual primitive value. The primitive data types on the AP CSA exam are:

- **int**: integers - 8 bits
- **double**: floating point numbers (ex. 3.93032) - 16 bits
- **boolean**: true or false
- **char:** characters declared in single quotation (ex. ‘A’)

**String:** sequence of characters **IS NOT A PRIMITIVE DATA TYPE!**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled.png)

**Declaring variables:**

data type + variable name = value

```java
int score;
```

- Declares an integer variable called score (value is 0 by default because it’s not initialized)

```java
int start = 1;
```

- Declares an integer variable called start with an initial value of 1

While printing variables, you can use “+” (string concatenation operator) to add them to another string:

```java
double price = 23.25;
System.out.println(“The price is ” + price);
```

Concatenation weird rule:

```java
String str;
str = "CS " + **(1 + 2)**; // CS **3**
str = "CS " + **1 + 2**; // CS **12**
```

When a variable is declared **final**, its value can’t be changed once it is initialized.

```java
final double PI = 3.14;
```

- Value of PI is finalized and cannot be changed

A variable name should **start with a letter** and can only include **letters, numbers, and underscores**. You can’t use any of the keywords or reserved words as **variable names in Java** (for, if, class, static, int, double, etc.)

- Use meaningful variable names!
- Variable names can only start with a letter, $, or _
- Start variable names with a lowercase letter and use camelCase: **lowerCamelCase**
- Only constants are traditionally capitalized (final variables)
    - ex. **final** double **PI** = 3.14;
    

Integer division:

5/2 = 2 **(NOT 2.5)**

Since the result is an integer, the answer gets **truncated**. **NOT ROUNDED!**

If one of the numbers is a **double,** the result will be a **double**

```java
double x = 5.0;
int y = 3;

System.out.println(x * y);
```

The result is 15.0 (a double)

## 1.4: Compound Assignment Operators

```java
int x;

x = x + 1; 
// Shortcut below
x++;

x = x - 1; 
// Shortcut below
x--;

x = x + 10; 
// Shortcut below
x += 10;

x = x - 10; 
// Shortcut below
x -= 10;

x = x * 10; 
// Shortcut below
x *= 10;

x = x / 10; 
// Shortcut below
x /= 10;

x = x % 10; 
// Shortcut below
x %= 10;
```

Note: **0 % any number = 0**

## 1.5: User Input

Import and initialize Scanner:

```java
import java.util.Scanner;
```

```java
Scanner sc = new Scanner(System.in);

// String input using sc.nextLine()
System.out.print("Enter string input: "); // ex. Ege
String stringInput = sc.nextLine();

// Integer input using sc.nextInt()
System.out.print("Enter integer input: "); // ex. 41
int intInput = sc.nextInt();

// Double input using sc.nextDouble()
System.out.print("Enter double input: "); // ex. 54.32
double doubleInput = sc.nextDouble();

// Boolean input using sc.nextBoolean()
System.out.print("Enter boolean input: "); // ex. True
boolean boolInput = sc.nextBoolean();
```

When using nextInt(), nextDouble(), nextBoolean() **BEFORE nextLine():**

Add a **buffer nextLine() method** inbetween them

```java
System.out.print("Enter integer input: "); // ex. 41
int intInput = sc.nextInt();

// BUFFER METHOD
sc.nextLine();

System.out.print("Enter string input: "); // ex. Ege
String stringInput = sc.nextLine();
```

Get multiple integers, doubles, booleans **from the same line:**

```java
System.out.println("Enter two integers **separated by a space:** "); // 56 43
int one = sc.nextInt(); // = 56
int two = sc.nextInt(); // = 43
```

## 1.6: Casting and Range of Variables

**Casting:** Turning a value of one type to another type (ex. double → int)

Double to integer:

```java
double x = 5.8;
int y = (int)x; // It would throw an error without the (int)
// (int) before any number **TRUNCATES (NOT ROUNDS)** it into an integer
System.out.println(y) // y = 5

// TO **ROUND** A DOUBLE TO AN INTEGER (**NOT TRUNCATE**):
y = (int)(x + 0.5); // Add 0.5 to the number, then use casting to turn it into an integer
System.out.println(y) // y = 6
```

Integer to double (implicit casting):

```java
int x = 5;
double y = x;
System.out.println(y) // y = 5.0
```

If **both numbers are integers** and we want to divide them and **get a double answer:**

```java
int int1 = 15;
int int2 = 2;
double myDouble;
 
myDouble = **(double)int1** / int2; // ONLY convert 1 of the values to double, then do the calculation.
// The result will be double when at least 1 of the values is a double.

// THIS CAN ALSO BE DONE BY ADDING A DOUBLE TO THE CALCULATION:
myDouble = **1.0 * int1** / int2;

System.out.println(myDouble) // **7.5**

// DIVIDING THE INTEGERS THEN CONVERTING THE RESULT TO A DOUBLE WILL NOT RETURN THE RIGHT ANSWER!
MyDouble = (double)(int1 / int2); // (double)7 = 7.0

System.out.println(myDouble) // **7.0**
```

Underflow & overflow:

```java
System.out.println(Integer.MIN_VALUE); // -2147483648
System.out.println(Integer.MAX_VALUE); // 2147483647
System.out.println(Integer.MIN_VALUE - 1); // **UNDERFLOW:** 2147483647 = MAX_VALUE
System.out.println(Integer.MAX_VALUE + 1); // **OVERFLOW:** -2147483648 = MIN_VALUE
```

# Unit 2: Using Objects

## 2.1: Understanding Objects

- A Java class is a template for creating an object.
- A Java object is a member (also called an **instance**) of a Java class. Each object has an **identity**, a **behavior** and a **state**.
- **Constructor methods** allow us to **create a new instance of a class,** **usually initializing instance variables.**

**Getter methods = accessors**

**Setter methods = modifiers**

Student object example:

```java
public class Student {
		/* 
		INITIALIZE THE ATTRIBUTES OF THE CLASS!
		PRIVATE VARIABLE = USE GET METHOD TO ACCESS!
		PUBLIC VARIABLE CAN BE ACCESSED FROM OUTSIDE THE CLASS!
		**!!!ALWAYS DECLARE THE ATTRIBUTES OF AN OBJECT PRIVATE!!! (like the String "name" in this example)**
		*/
    **private** String name;
    **public** String surname;
    public int level;
    public String schoolName;
    public int ID;

		// **CONSTRUCTOR METHOD** (INITIALIZES OBJECT)
    public Student(String newName, String newSurname, int newLevel, String newSName, int newID) {
        name = newName;
        surname = newSurname;
        level = newLevel;
        schoolName = newSName;
        ID = newID;
    }
		// **GET METHOD** (RETURNS THE VALUE OF THE VARIABLE)
		public **String** getName() {
        return this.name;
    }

		// S**ET METHOD** (CHANGES THE VALUE OF THE VARIABLE)
		public **void** setName(String name){
				this.name = name;
		}
}
```

This class can’t run because it does not have a main method!

Access the object from another class:

```java
public class MyProgram {
    public static void main(String[] args) {
        Student student1 = new Student("Ege", "Gürsel", 11, "RC", 46);
        
        System.out.println(student1.name); // THIS WILL RESULT IN AN ERROR BECAUSE "name" IS **PRIVATE**!
				System.out.println(student1.getName()); // ACCESS THE VARIABLE VIA **GET METHOD** "getName()" 
        System.out.println(student1.surname);
        System.out.println(student1.level);
				
				// CHANGES THE ATTRIBUTE "name" OF THE STUDENT OBJECT "student1" VIA **SET METHOD "setName()"**
				student1.setName("Kuzey"); 
				System.out.println(student1.getName()); // PRINTS "Kuzey"
    }
}
```

This can be done because the object is **public**

Class definition of a pineapple:

```jsx
public class Pineapple
{
    private boolean isRipe;
    private String color;
    private double weight;

    // Rest of class goes here
}
```

**Every Pineapple object will have all of the attributes and methods contained in the class definition! (isRipe, color, weight)**

## 2.2: Creating and Storing Objects (Instantiation)

Vector object example code:

**Vector.java**

```jsx
public class Vector {
		// THE ATTRIBUTES OF THE OBJECT (ALL PRIVATE):
    private double x;
    private double y;

    public Vector(double x, double y) { // CONSTRUCTOR METHOD
        this.x = x;
        this.y = y;
    }

    public double getX() { // GET METHOD
        return this.x;
    }

    public double getY() { // GET METHOD
        return this.y;
    }

    public double magnitude() { // GET (MAGNITUDE) METHOD
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    public void setX(double newX) { // SET METHOD
        this.x = newX;
    }

    public void setY(double newY) { // SET METHOD
        this.y = newY;
    }

		public Vector add(Vector other) { // 
        double newX = this.x + other.x;
        double newY = this.y + other.y;
        return new Vector(newX, newY);
    }
		**// "toString()" method is used to print objects**
		public String toString() {
        return "(" + this.x + "," + this.y + ")";
    }
}
```

**Main.java**

```jsx
public class Main {
    public static void main(String[] args) {
				**// INSTANTIATE VECTORS (create instances of the Vector class object)**
        Vector u = new Vector(1.2, -5);
        Vector v = new Vector(3, 5);

        System.out.println(u.getX()); // 1.2
        System.out.println(u.getY()); // -5
        System.out.println(u.magnitude());

        u.setX(3.5);
        u.setY(6.4);

        System.out.println(u.getX()); // 3.5
        System.out.println(u.getY()); // 6.4
        System.out.println(u.magnitude());

        Vector z = u.add(v); // Create new Vector z by adding the vectors u and v

        System.out.println(z.getX()); // 6.5 (3.5 + 3)
        System.out.println(z.getY()); // 11.4 (6.4 + 5)
        System.out.println(z.magnitude());
				
				**// PRINTING THE OBJECTS PRINTS OUT WHAT IS DEFINED IN THE CLASS' "toString()" METHOD!**
				System.out.println("Vector u: " + u);
        System.out.println("Vector v: " + v);
        System.out.println("Vector z: " + z);
    }
}
```

## 2.3: Method Overloading

Create another constructor for the same object:

- Overloading a class’ constructor allows the user to choose **which instance variables are set to default values and which are immediately customized.**

**Example (overloading constructor method):**

**Point.java**

```jsx
public class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // ANOTHER CONSTRUCTOR THAT DOESN'T REQUIRE TWO ATTRIBUTES, the "y" attribute is = 0 automatically
    public Point(double x) {
        this.x = x;
        this.y = 0;
    }

    public String toString() {
        return "(" + this.x + "," + this.y + ")";
    }

    public double getDistance(Point other) {
        double xDiff = this.x - other.x;
        double yDiff = this.y - other.y;
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    }
}
```

**PointProgram.java**

```java
public class PointProgram {
    public static void main(String[] args) {
        Point p1 = new Point(10.3, 12.5);
        Point p2 = new Point(5.12, -6);
        Point p3 = new Point(43);

        System.out.println("Point 1: " + p1); // Calls the "toString()" method of the object
        System.out.println("Point 2: " + p2);
        System.out.println("Distance between the two: " + p1.getDistance(p2));

        System.out.println(p3); // The y-value of p3 is zero because it is left blank
    }
}
```

Ways to overload a constructor method:

```java
Pineapple(String color) // Original constructor

Pineapple() // Remove parameter
Pineapple(String color, int age) // Add parameter
Pineapple(int age, String species) // Remove & add parameter
```

A [**reference variable](https://www.notion.so/AP-CS-A-10abd22fce2345ad8bb0e237256675fc)** is the memory address of the object:

```java
Pineapple myPineapple = new Pinapple("yellow");
```

“**Pineapple**” is the name of the **class**. Its name can’t be changed to overload that specific method.

The **reference variable** in this case is “**myPineapple**” and it **points at the object in memory**.

### A class is a template used for the creation of objects. An object is an instance of a class.

**null** value allows a reference variable to be empty and not hold any memory address

**Actual parameters** are the variables that are transferred to the function when it is requested.

```java
person.WalkForward(10); // 10 is an **actual parameter**
```

**Formal Parameters** are the values determined by the function that accepts values when the function is declared

```java
public void WalkForward(int stepCount) { // stepCount is a **formal parameter**
		this.position += stepCount;
}
```

## 2.4: Calling a Void Method

**METHODS:** Procedures that allow us to control and define the behavior of an object.

**Void methods:** We don’t have to identify the type of the result. Used in **set methods (does not return value)**

**Non-void methods:** We have to identify the type of the result in the method name. Used in **get methods (returns value)**

```java
// void method (doesn't return anything): SET METHOD
public void setName(String newName) {
		this.name = newName;
}

// non-void method (returns name): GET METHOD
public String getName() {
		return this.name;
}
```

## 2.5 & 2.6: Calling a Void Method with Parameters

**Parameters:** The formal names given to the data that gets passed into a method.

**Static Variables:** Used for variables that store **common properties of all objects in a class**. It’s memory efficient because static variables get memory only once at the time of class loading.

Using static variables:

**Worker.java**

```java
public class Worker {
    private String name;
    private int salary;
    private double rate;
    **private static int numWorker;**

    public Worker(String name, int salary, double rate) {
        this.name = name;
        this.salary = salary;
        this.rate = rate;

        numWorker++;
    }
    public Worker(String name) {
        this.name = name;
        this.salary = 50000;
        this.rate = 0.2;

        numWorker++;
    }

    // GET METHOD IS STATIC BECAUSE "numWorker" IS STATIC
    public static int getNumWorker(){
        return numWorker;
    }
}
```

**WorkerProgram.java**

```java
public class WorkerProgram {
    public static void main(String[] args) {
        Worker w1 = new Worker("Fatih");
        Worker w2 = new Worker("Ege", 65000, 0.25);
				
				// PRINTS THE TOTAL NUMBER OF WORKER OBJECTS (USE THE CLASS NAME TO ACCESS STATIC VARIABLE)
        System.out.println(Worker.**getNumWorker()**);
    }
}
```

## 2.7: String Objects

String keyboard starts capitalized: **Reference object** **NOT PRIMITIVE** DATA TYPE

Strings are **immutable:** Once a String variable has been assigned a value, the value cannot be modified but the variable can be assigned to a different value.

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%201.png)

These are non-void methods. **They just return a value without changing the original strings value.** They name.toUpperCase() does NOT change the string “name”s value.

ex.

```java
String name = "Ege Gürsel";

name.toUpperCase(); // DOES NOTHING

System.out.println(name); // "Ege Gürsel"
System.out.println(name.toUpperCase()); // "EGE GÜRSEL"
```

Strings can be concatenated with String objects:

```java
String firstName = "Ege";
String lastName = "Gürsel";

System.out.println(firstName + " " + lastName); // "Ege Gürsel"
// THIS WON'T CONCATENATE INTEGERS AND DOUBLES, IT WILL ADD THEM!
```

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%202.png)

Quotation marks can be written in strings by writing **\”**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%203.png)

## 2.8: String Methods

**String**.**indexOf(char OR string)**

```java
String forest = "Amazon Rainforest";
forest.indexOf('A'); // 0
forest.indexOf("maz"); // 1
forest.indexOf('a'); // 2
forest.indexOf('g'); // -1
forest.indexOf('R'); // 8
```

If the character cannot be found, “indexOf()” returns -1

**String.concat(String)**

```java
String s1 = "Hello ";
String s2 = "World!";
String s3 = s1.concat(s2); // "Hello World!"
```

**String.length()**

```java
String s1 = "Ege";
int x = s1.length() // 3
```

**String.substring(startIndex, endIndex+1)**

```java
String s1 = "Robert";
String s2 = s1.substring(**2, 4**) // ro**BE**rt: **s2 = "be"
// Overloading this method (no end index):**
String s3 = s1.substring(**2**) // Starts at index, includes the rest of the string: **s3 = "bert"
// IndexOutOfBounds Exception:**
String s4 = s1.substring(**4, 7**) // index 7 is out of bounds because the length of string is 6 
```

All of these variables point to the **same address in memory** (only one copy of each distinct string value is stored). HOWEVER, if we declare a variable as **new**, a new “Ege” will be created at a **different address in memory:**

```java
String s1 = "Ege";
String s2 = "Ege";
s1 == s2 // **true**

String s3 = new String("Ege");
s2 == s3 // **false** (different locations in memory)
```

== compares memory address (reference equality)

Strings with different memory addresses can be compared with:

**String.equals(String)**

```java
String s1 = new String("Ege");
String s2 = new String("Ege");
boolean checkString = s1.equals(s2) // **true**
```

**equals() method does not compare the memory addresses, it compares values (unlike “==”)**

**LOGICAL EQUALITY uses .equals() to compare the object data from one object to another!**

“Proper way to compare reference variables in Java”

### A primitive variable's information is stored as the value of that variable, whereas a reference variable holds a reference to information related to that variable.

```java
String name1 = **new String**("Ege");
String name2 = "Ege";

System.out.println(name1 == "Ege"); // **false**
System.out.println(name2 == "Ege"); // **true**
```

**String.compareTo(String)**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%204.png)

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%205.png)

### Libraries

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%206.png)

## 2.9: Wrapper Classes: Integers and Doubles

We can convert primitive types to object (reference) types using **wrapper classes.**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%207.png)

```java
Integer x = new Integer(5);
Double y = new Double(3.14);

Integer z = 5;
Double v = 3.14;
```

**Unboxing:** Converting an object of a wrapper type to its corresponding primitive value.

**Autoboxing:** Converting a primitive value to its corresponding wrapper type

```java
double d1 = 10.0;
Double d2 = 20.0;
Double d3 = new Double(30.0);
double d4 = new Double(40.0);

System.out.println(d1 + d2 + d3.doubleValue() + d4); // 100.0
```

d3.doubleValue() is not necessary due to **unboxing**.

```java
// **Autoboxing of integer**
Integer i1 = 46;

// Auto-**unboxing of Integer**
int i2 = i1;
```

Objects vs Primitives:

- An object stores an **address** as a value while a primitive stores a **literal** value.

## 2.10: Static Methods

**Static methods:** Methods that can be called without creating an object of a class. They are referenced by the class name itself.

ex. **Math class contains static methods**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%208.png)

Static methods don’t need an instance:

```java
int x = Math.abs(-5);
int y = Math.pow(2, 5); // base, exponent
int z = Math.sqrt(16);
int v = Math.random(); // returns a random double value **greater than or equal to 0.0, and less than 1.0**
```

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%209.png)

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2010.png)

# Unit 3: Boolean Expressions and If Statements

Booleans can use **relational operators** to store true/false information.

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2011.png)

```java
String myName = "Ege";
String myName2 = **new** String("Ege");

boolean compareNewName = myName == myName2; // **false**
boolean compareSameNames = myName == "Ege"; // **true**
```

**new** variables have a separate location in memory even though the value stored is the same

**Relational operators compare addresses in memory** (unlike the **equals()** method which compares values of variables, not memory addresses)

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2012.png)

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2013.png)

**DECLARE AN INSTANCE VARIABLE BUT DON’T INITIALIZE IT: VALUE IS NULL**

Random integer in an inclusive range:

```java
// Random integer between max and min (inclusive: including min and max)
Min + (int)(Math.random() * ((Max - Min) + 1))
```

### Compounds Operators

p v q :: p AND q 

p ^ q :: p OR q

!p = p’ :: NOT p

p **⇒** q :: p implies q

### **De Morgan's Law**

The complement of the union of two sets is the intersection of their complements, and also the complement of intersection of two sets is the union of their complements.

`!(A && B)` = `!A || !B` 

`!(A || B)` = `!A && !B` 

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2014.png)

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2015.png)

### Shortcut Circuit

`boolean myBool = true **&&** (5 / 0 == 0);` 

The `5 / 0 == 0` operation will be evaluated

`boolean myBool = true **||** (5 / 0 == 0);`  

The `5 / 0 == 0` operation will not be evaluated

false **&&** true = false

true **&&** false = false

- 5 million false statements **OR 1 true statement = TRUE**
    - true **or** false = **true**
- 5 million true statements **AND 1 false statement = FALSE**
    - true **and** false = **false**

**Relational operators cannot be used on arithmetic expressions:**

**************************************Arithmetic Operators**************************************

- +
- -
- *
- /
- %

****************************************Relational Operators****************************************

- ==
- =!s
- <

## Units 1-3 Extra Notes

```java
Object == null // Checks if an object is null or not
```

If object == null, object.method() will throw **NullPointerException**

You can’t invoke methods on a **null reference**

```java
double val = -0.7;
int roundedVal = (int) (val + 0.5)
```

The code segment does not work as intended because the expression “(int) (val + 0.5)” rounds to the nearest integer only when val is positive.

```java
int one = 1;
int two = 2;
String zee = "Z";
System.out.println(one + two + zee); // **3Z**
System.out.println(zee + one + two); // **Z12**
System.out.println(one + (two + zee)); // **12Z**
```

Integers can be converted to double and can be given as parameter to methods that require double values, **but doubles can’t be used as integers:**

```java
int num1 = 10;
getProduct(num1);

public static void getProduct(double y) {
        System.out.println(5 * y);
}
```

Random integer between 25 and 60, inclusive:

```java
int rn = (int) (Math.random() * 36) + 25;
```

# Unit 4: Iteration

### While Loop

**While loop** repeats code **while a condition is true**

```jsx
// While condition is always true: **infinite loop**
while(true)
{
    System.out.println("Hello");
}
```

“**break**” can be used inside a loop to end it

```jsx
import java.util.Scanner;
public class MyProgram
{
    public static void main(String[] args)
    {
        Scanner scanner = new Scanner(System.in);
        while (true)
        {
            System.out.println("Who are you?");
            String name = scanner.nextLine();
            
            if(name.equals("Joe")==false){
                continue;
            }
            while(true)
            {
                System.out.println("Hello, Joe. What is the password? (It is a fish.)");
                String password = scanner.nextLine();
                if(password.equals("swordfish")==false){
                    System.out.println("Wrong!");
                    continue;
                    }
                    break;
            }
            System.out.println("Access Granted!");
            return;
        }
    }
}

```

### For Loop

**********************For loop********************** repeats code for a fixed number of times

```java
for (int i = 0; i < n; i += 2)
{
    if (/* condition to test */)
    {
        /* perform some action */
    }
}
```

This code will be run **(n+1)/2** amount of times **MAX**

### Algorithms Using Strings

Strings are **immutable**, so a method can’t change a String object.

You can only create a new string object and incorporate an existing string object into it.

# Unit 5: Writing Classes

## 5.3

**Precondition:** A condition that must be true for your method code to work, (the assumption that the parameters have values and are not null.) The methods could check for these preconditions, but they do not have to. The precondition is what the method expects in order to do its job properly.

**Postcondition:** A condition that is true after running the method. It is what the method promises to do.

```java
/**
  * Constructor that takes the x and y position for the
  * turtle
  * **Preconditions**: parameters x and y are coordinates from 0 to
  *    the width and height of the world.
  * **Postconditions**: the turtle is placed in (x,y) coordinates
  * @param x the x position to place the turtle
  * @param y the y position to place the turtle
  */
 public Turtle(int x, int y)
 {
   xPos = x;
   yPos = y;
 }
```

It’s good practice to only modify objects when the method **postcondition** has specified the modification.

### 5.6

**User defined classes** can be permanently modified in a method when passed as a parameter to a method.
^^Using setter (mutator) methods:

### 5.7

Each object has its own copy of the **instance variables**, but all objects share a copy of the **static variables**

**********************************Static variables********************************** are initialized in the class file (not in a method)

**Static methods** can only access other static instance variables and class methods

```jsx
public **static** String method1() // CAN ONLY RETURN **STATIC** STRINGS
```

### 5.8 - Scope & Access

```java
for(int i = 0; i < 10; i++) {
	// the variable "i" can only be used inside this for loop
}
// i isn't defined in this scope
```

**Local Variable:** A variable **defined in a method/constructor**

^^Only exists inside the method it’s defined in

Shadowing: If 2 variables have the same name in a scope, **the variable with the more general scope no longer exists.**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2016.png)

```java
public class PrintQuestion
{
    private static String phrase = "Hello World!";

    public static void printPhrases()
    {
        String phrase = "hi";
        System.out.println(phrase);
        phrase = "hello";
    }
}
```

After `printPhrases` was called from `main`, the value of the static variable `phrase` would still be “Hello World!” because inside the run method, the local variable phrase shadows the instance variable phrase. The value of the outer “phrase” has not been changed!

### 5.9: this Keyword

The `this` keyword references the object that called the method.

`this` can’t access the **private variables of other objects** of the same class.

Static methods are not called using an object. Thus, `this` can’t be used in static methods.

```java
public class Main
{
    private **static** int n = 0; // Static variable can be accessed from all objects of this class

    public static void bar()
    {
        Main m1 = new Main(); // n = 1
        Main m2 = new Main(); // n = 2
        Main m3 = new Main(); // n = 3
        m1.foo(); // prints 3
    }

    public Main()
    {
        n = n + 1;
    }

    public void foo()
    {
        System.out.println(n);
    }
}
```

```java
public class BoolTest {
		private int one;
	
		public BoolTest(int newOne) {
				one = newOne;
		}
	
		public int getOne() {
				return one;
		}
	
		public boolean isGreater(BoolTest other) {
				// **this method can be:**
				return one > other.one;
				return one > other.getOne();
				return getOne() > other.one;
				// **accessing private variables of other instances from the same class is ok.**
		}
}
```

# Unit 6: Array

Creating an array:

```java
int[] arr1 = new int[5]; // Number of elements in the array: 5
```

When an array is created this way, Java assigns default values for each element in the array:

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2017.png)

Creating an array with initializer list:

```java
int[] arr1 = {5, 4, 6, 2};
int lastIndex = arr1**.length** - 1; // **length is not a method**
System.out.println(arr1[4]); // **ArrayIndexOutOfBounds** Exception: compile error
```

```java
int x = 25;
int[] numArray = new int[x];
x = 100;
System.out.println("x is " + x); // **100**
System.out.println("The size of numArray is " + numArray.length); // **25**
```

## 6.3: For-each Loop

Access every element of an array and want to refer to elements through a variable name instead of an array index.
You **can’t modify** an array when you use a for each loop.

```java
Student julian = new Student("Julian", "Jones", 9);
Student larisa = new Student("Larisa Torres", 10);
Student amada = new Student("Amada Robin", 10);

Student[] classroom = {julian, larisa, amada, mikka, jay};

for(**Student** i : classroom) {
    System.out.println(i.getName());
}
```

```java
int[] numArray =  {12, 17, 65, 7, 30, 88};

public double getAverage(int[] arr)
{
		double sum = 0;
		for (**int** val : arr) {
		   sum += val;
		}
		return sum / arr.length;
}
```

Changing the value of every element in an array:

```java
int[] numbers = {1, 2, 3, 4};
for (int i = 0; i < numbers.length; i++)
{
     numbers[i] += 5;
}
```

**Adds 5** to every number in the original list

```java
int[] numbers = {1, 2, 3, 4};
for (int number : numbers)
{
     number += 5;
}
```

**Doesn’t add 5** to every number in the original list

**For-each loops change the value of the local variable** (”number” in this case)

# Unit 7: ArrayList

When an int or double value is added to an ArrayList, it is automatically converted to its Wrapper class, and when it is accessed, is transformed back into its primitive value.

Arrays have a fixed number of values, while ArrayLists can change in size.

An ArrayList only contains reference values.

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2018.png)

**arrlist.remove(index)** returns the value that is being removed from the index.

**arrlist.set(index, String)** returns the old value of the index that is being changed.

************************arrlist.add(index, String)************************ adds new element to the given index. If no index is given, element is added to the end of arrlist.

************************arrlist.addAll(ArrayList/array)************************ appends all the elements in the given array to the arrlist

# Unit 8: 2D Array

```java
int[][] array = {{3, 5, 7, 8}, {125, 784, 267, 674}, {9, 8}};

array.length // Number of columns (3)
array[0].length // Number of elements in the first row (4)
// **array[row][column]** to access elements
```

Printing all elements in a row/column of a 2D array:

```java
// Print first **row**
for(int i = 0; i < arr[0].length; i++) {
			System.out.println(arr[0][i]);
}

// Print first **column**
for(int i = 0; i < arr.length; i++) {
			System.out.println(arr[i][0]);
}
```

Accessing elements of a 2D array:

- **Row-major order**: Traverses the array across each row.

```java
for(int row = 0; row < arr.length; row++) {
		for(int col = 0; col < arr[row].length; col++) {
				System.out.println(**arr[row][col]** + " ");
		}
		System.out.println();
}
```

- **Column-major order**: Traverses the array across each column.

```java
for(int row = 0; row < arr.length; row++) {
		for(int col = 0; col < arr[row].length; col++) {
				System.out.println(**arr[col][row]** + " "); // **col stays consistent as row iterates**
		}
		System.out.println();
}
```

Traversing 2D Arrays using **enhanced loops**:

```java
for(int[] row: arr) {
		for(int col: row) {
				System.out.println(col);
		}
}
```

## Sorting Algorithms

**Selection Sort:** Iterates through each index and swaps the current index with the minimum value that exists in the indices greater than the current index.

```java
public static void SelectionSort(int[] arr) {
      int n = arr.length;
      for (int i = 0; i < n - 1; i++) {
          int min = i;
          for (int j = i + 1; j < n; j++) {
              if (arr[j] < arr[min]) {
                  min = j;
              }
          }
          int temp = arr[min];
          arr[min] = arr[i];
          arr[i] = temp;
      }
}
```

For array with 8 elements: 7 + 6 + 5 + 4 + 3 + 2 + 1 = 28 comparisons

**Insertion Sort:** Sets the first index as sorted, and shifts each subsequent value into the correct position by finding the lowest value on the sorted side of the array at indices lower than the current index.

```java
public void sort() {
    int size = contacts.size();
    for(int i = 1; i < size; i++) {
        Contact key = contacts.get(i);
        int j = i - 1;
        while (j > -1 && contacts.get(j).getName().compareTo(key.getName()) > 0) {
            contacts.set(j + 1, contacts.get(j));
            j--;
        }
        contacts.set(j + 1, key);
    }
}
```

Insertion Sort is faster than Selection Sort if the array is already slightly sorted because insertion sort can take advantage of the existing order and reduce the number of comparisons and swaps, while selection sort always has to scan through all remaining elements regardless of their order.

# Unit 9: Inheritance

**Inheritance:** Creating a hierarchy of classes which allows for the reuse of common attributes and behaviors.

**“IS-A”** Relation (inheritance): **A child class is a parent class (it is a more specific example of a broader class).**

- **IS-A** relationship is achieved by **extending an interface or class** by using the **extends** keyword.
- **********IS-A********** relationships are **NOT symmetrical**, subclasses can access the superclass’ variables and methods via the **super** keyword, but the parent can’t access the childs’ attributes and methods.

```java
// **Apple** is a **Fruit** (and can access the Fruit's common attribute **color** using the ************super************ keyword)
class Apple **extends** Fruit {
		private String type;
		
		public Apple(String color, String type) 
    {
    	**super**(color);
    	this.type = type;
    }
		public String getType() {
				return type;
		}
		// **getColor method is already defined** in the superclass Fruit and is inherited in sublclass Apple due to the **super** keyword
}
```

**“HAS-A”** Relation (association): An **instance** of Class B being created in another Class A means that **Class A has a Class B.**

```java
// **Room** has a **Table**
class Room {
    Table table = new Table();
}
```

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2019.png)

**Subclass properties:**

1. Modified/Overridden methods
2. Additional instance variables specific to the subclass
3. Additional methods specific to the subclass

Subclasses **don’t inherit the superclass constructor →** the ****************super()**************** method calls the superclass constructor from the subclass!

When a subclass object is created, **it must also invoke one of the constructors of the superclass.** If the superclass has a default constructor (a constructor with no parameters), then it will be automatically called by the subclass constructor. However, if the superclass has a constructor with parameters, then the subclass constructor must **explicitly call it using the super keyword** and provide appropriate arguments.

---

### Parent/Mother Class (superclass):

**Person**

- instance vars: **name, surname**

### Child Classes (subclasses):

**Student**

- instance vars: **super(name, surname),** grade, gpa

**Teacher**

- instance vars: **super(name, surname),** profession, age

******IS-A****** Relationship: Every **Student** and **Teacher is a Person.**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2020.png)

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2021.png)

**Note:** Child objects of child objects can be created using the **extends** keyword

---

### Super Construction

The **super** keyword in java is a reference variable that is used to **refer to parent class objects’ variables, methods, constructors.**

The super keyword must be used as the **first statement in a subclass constructor.** If you try to use it after any other statement, you will get a compile-time error because the superclass constructor must be invoked before any other initialization in the subclass constructor.

It can **call:**

1. the superclass constructor
2. a public method in the superclass
3. the superclass object

The super keyword **cannot be used to access a superclass variable directly.**

**Super** automatically calls for the attributes of the parent class (**name, surname** in this case).

```java
public class Student extends Person {
		// NO NEED TO RE-INITIALIZE SUPERCLASS' INSTANCE VARIABLES -> USE **SUPER**
		private int grade;		

		// CONSTRUCTOR USING **SUPER**
		public Student(String name, String surname, int grade) {
				super(name, surname);
				this.grade = grade;
		}
		
		// OVERLOADING CONSTRUCTOR USING **SUPER**
		public Student(String name, int grade) {
				super(name, "Gürsel");
				this.grade = grade;
		}

		// **OVERRIDING toString** using ******************************SUPER****************************** (@Override is only for cleaner code)
		******************************@Override****************************** // toString of this class would be superclass' toString method if we didn't override
		************************************************************public String toString() {
				return super.toString() + ", grade: " + grade;
		}
}
```

### Method Overriding

******Method Overriding****** is when a method has the same name and parameters, but a different output regarding the context. It grants the **specific** implementation of the method which is **already provided by its parent class or superclass. (ex. toString methods of subclasses that are different than superclass)**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2022.png)

**Overriding order:** Java first looks in a subclass for a method signature. If it is found there, it executes that method. Otherwise it checks the superclass methods.

**Overloading vs. Overriding:** Overloading is about the same function have different signatures (parameters). Overriding **[](https://www.geeksforgeeks.org/overriding-in-java/)**is about the same function, same signature but different classes connected through inheritance. Overloading is about the same function having different signatures. **[Overriding](https://www.geeksforgeeks.org/overriding-in-java/)** is about the same function, same signature but different classes connected through **inheritance.**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2023.png)

### Polymorphism

- **Compile-time Polymorphism:** Method overloading (not in AP curriculum)
- **Runtime Polymorphism (Dynamic Method Dispatch):** Call to an overridden method is resolved at runtime rather than compile-time.

In order for a program to **compile**, any method that an object uses must be **defined in the class where the object is declared.**

To choose **which method to run:** At **compile time,** Java first looks in the **instantiated class,** then during **runtime,** Java **checks the superclasses if the method is not found during compile time.**

![Untitled](AP%20CS%20A%2010abd22fce2345ad8bb0e237256675fc/Untitled%2024.png)

At runtime, the methods in the actual object type get executed. If the method doesn’t exist there, Java checks the method of the **superclass.**

superclass can’t access subclass methods :: runtime error

A **subclass** always has its own constructor, either explicit or implicitly created. (implicit ⇒ Java calls the no-argument superclass constructor)
You cannot instantiate an object in a more general class than it is declared

The `Object` class sits at the top of the Java class hierarchy for all objects and becomes the default superclass when an object doesn’t explicitly extend another class.

### 9.7: Object Superclass

Every object created in Java can use the `Object` class methods since the object class is at the **top** of the hierarchy.

11 methods in the **Object** class

- boolean **equals**(Object other): compares whether two variables are represented by the same object
- String **toString**()

```java
Object o1 = new Object();
Object o2 = new Object();

// calling the **equals** method of the **Object class**
System.out.println(o1**.equals**(o2)); // ********true********
```

**String class** is a subclass of the **Object superclass**

- String class overrides the equals method of Object class and returns true if all characters are the same:

```java
String s1 = "Ege";
String s2 = "Kuzey";

// calling the **equals** method of the **String class (overrides Object's method)**
System.out.println(s1**.equals**(s2)); // **false**
```

# Unit 10: Recursion

**************Recursion:************** When a method calls itself.